---
title: "base R, pt.1"
subtitle: "https://github.com/llevenets/intro-r"
format: 
  revealjs:
    css: custom.css
    slide-level: 3
    slide-number: c/t
    progress: false
    fig-format: svg
    fig-width: 6
    code-copy: true
execute: 
  echo: true
highlight-style: pygments
knitr: 
  opts_chunk:
    comment: "#>"
    collapse: true
link-external-icon: true
---

### Інтро

-   R це мова програмування для статистичних обчислень та візуалізації даних яка використовується вже понад 30 років - перші бінарні файли були опубліковані у серпні 1993 року. Створений Россом Іхакою та Робертом Джентльменом, на основі мови S та Sheme, R був широко прийнятий на використання у області дата-майнінгу, аналізу даних та біоінформатики
-   R є функціональною програмною мовою і створювався специфічно для статистичних обчислень, через що має низку особливостей, наприклад індексація починаючи з одиниці, векторизація обчислень та lazy evaluation
-   Ядром R є інтерпретована комп’ютерна мова, яка дозволяє розгалуження та цикли, а також модульне програмування за допомогою функцій. Більшість видимих для користувача функцій у R написані на R, проте частина базових функцій є написаною на C, C++ та FORTRAN
-   Програмне забезпечення R є [вільним програмним забезпеченням із відкритим кодом]{.emphasized}, офіційною частиною GNU project і розповсюджується під копілефт ліцензією GNU GPL
-   R підтримується сімейством Unix-подібних ОС, Windows та Mac ОС
-   R поставляється зі своїм власним вбудованим CLI
-   RStudio Desktop є вільним (ліцензія GNU AGPL) кросплатформеним IDE початково розробленим специфічно під R (на сьогодні розширеним до роботи з низкою інших популярних мов).
-   З R також достатньо зручно працювати використовуючи популярний у науковій спільноті відкритий інтерактивний блокнот Jupyter Notebook/Lab або використовуючи текстовий редактор Emacs з аддоном ESS

### Рідлист

Як завжди одним з перших місць для пошуку інформації є офіційні мануали:

-   [R FAQ — Frequently Asked Questions on R](https://cran.r-project.org/doc/FAQ/R-FAQ.html)
-   [An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)

А також:

-   [Advanced R, Second Edition (Hadley Wickham, 2019)](https://adv-r.hadley.nz/index.html) — я дуже раджу спробувати прочитати розділ Foundations, або хоча б глави з другої (Names and values) по четверту (Subsetting)

Усяке різне:

-   [What every computer scientist should know about floating-point arithmetic (David Goldberg, 1991)](https://dl.acm.org/doi/10.1145/103162.103163) — лонгрід про особливості арифметичних операції з плаваючою комою
-   [Structure and Interpretation of Computer Programs, second edition (Harold Abelson, Gerald Jay Sussman and Julie Sussman, 1996)](https://web.mit.edu/6.001/6.037/sicp.pdf) — якщо Ви зацікавтеся програмуванням, то завжди можете спробувати прочитати оцей класичний трактат на 800 сторінок задля інтересу

### Бібліотеки

[Функція]{.emphasized} є серцем програмної мови. Функція це набір команд, чітко визначена поведінка, упорядкований самостійний блок коду, що виконує конкретне завдання.

Функції (а також інші об'єкти) можуть бути зібрані у [бібліотеки]{.emphasized} або [пакети]{.emphasized}. R поставляється з набором системних бібліотек (System Library), що включає у себе пакет базових функції, формальних методів та класів (`base`, `methods`), пакети для розробки бібліотек та аналізу коду, пакети графіки (`graphics`, `lattice` etc), низку пакетів для статистичного аналізу та моделювання (`stats`, `nlme`, `survival` etc), а також пакет наборів даних (`datasets`)

Низка бібліотек необхідних для базового функціювання R автоматично завантажуються при запуску нового робочого сеансу. Додаткові бібліотеки можуть бути завантажені (приєднанні) у робочий простір командою `library()`

```{r}
#| eval: false
library(MASS)
```

Викликати індивідуальну функцію або інший об'єкт без завантаження усієї бібліотеки можливо використавши конструкцію типу `package::function()`

```{r}
# функція пошуку раціонального наближення методом неперервного дробу з пакету MASS
MASS::fractions(sqrt(2))
```

Подібний синтаксис також може бути застосований у випадку коли одночасно завантажені бібліотеки мають однакове ім'я для якоїсь функції і одна з них маскує іншу

###  {#slide-id1 data-menu-title="Бібліотеки"}

Щоб завантажити бібліотеку під час робочої сесії [вона має бути встановлена]{.emphasized} на ваш локальний комп'ютер, чого можна досягти командою `install.packages()` або скориставшись вкладкою Packages GUI RStudio

Основним репозиторієм бібліотек R слугує [CRAN](https://cran.r-project.org/web/packages/index.html), що на даний момент хостить понад 20к бібліотек

```{r}
#| eval: false
# Бібліотека, що фактично складається лише з датасету пінгвінів Палмера
install.packages("palmerpenguins")
```

Репозиторієм бібліотек, що є розробленими специфічно для цілей біоінформатиків слугує FOSS-проект [Bioconductor](https://www.bioconductor.org/about/). Bioconductor має свій власний менеджер пакетів, що має бути попередньо встановлений як звичайна бібліотека

```{r}
#| eval: false
# DO NOT RUN
install.packages("BiocManager")
BiocManager::install("palmerpenguins") # лише для прикладу, Biocondctor не хостить даний пакет
```

Бібліотека також може бути встановлена безпосередньо із сурса

```{r}
#| eval: false
# необхідно вказати шлях до директорії куди збережено архів бібліотеки
install.packages("./palmerpenguins_0.1.1.tar.gz", type = "source", repos = NULL)
```

Dev-версія бібліотеки за необхідності зазвичай може бути встановлена з GitHub розробника

```{r}
#| eval: false
# install.packages("remotes")
remotes::install_github("allisonhorst/palmerpenguins")
```

###  {#slide-id2 data-menu-title="Бібліотеки"}

[Усі бібліотеки поставляються з розгорнутою документацією, прикладами та віньєтками.]{.emphasized} Розгорнута інформація про бібліотеку - опис, версія, автор, сурс-архів та бінарні файли, залежності, імпорти, документація у форматі .pdf та короткі туторіали зазвичай можуть бути знайдені на відповідній сторінці CRAN або Bioconductor, e.g. [palmerpenguins: Palmer Archipelago (Antarctica) Penguin Data](https://cran.r-project.org/web/packages/palmerpenguins/index.html)

Для пошуку документації також можуть бути використані сайти-агрегатори типу [RDocumentation](https://www.rdocumentation.org/) та [rdrr](https://rdrr.io/)

За документацією (та власне кодом!) також завжди можна звернутися безпосередньо до репозиторію розробників, зазвичай на GitHub. Популярні бібліотеки або сімейства бібліотек нерідко мають свої власні сайти з документацією, e.g. [palmerpenguins 0.1.1](https://allisonhorst.github.io/palmerpenguins/)

Звернутися до документації під час роботи R можливо за допомогою команди `help()` або `?`

```{r}
#| eval: false
# виклик допомоги для функції виклику допомоги

help("help") # " help is the primary interface to the help systems. "
?help

help("?") # " Documentation Shortcunts - These functions provide access to documentation."
?`?`      # Зверніть увагу на ` ` навколо оператора

help("??") # " Search the Help System - Allows for searching the help system for documentation
?`??`      # matching a given character string in the (file) name, alias, title, concept... "
```

### `c()` та `< -`

[Оператор призначення (assignOps)]{.emphasized} `<-` та [оператор конкатенації]{.emphasized} `c()` виконують дві прості функції – пов'язують об'єкт (значення, змінну) із іменем та комбінують об'єкти у вектор (або лист) відповідно

```{r}
x <- 1
print(x) # виклик print() не є обов'язковим

y <- c(1, 2)
print(y)

z <- c(x, y) 
print(z) # значення ідентичне print(c(x, y)) 
```

Викликавши `help("assignOps")` можна виявити існування двох інших операторів:

-   Оператор суперпризначення `<<-`, що може використовуватися у функціях для зміни глобальних змінних;
-   Оператор `=`, що є подібним (хоча і не ідентичним) `<-`, але типово використовується для зв'язування іменованих аргументів функції зі значеннями;
-   А також дзеркальні `->` та`->>`, що виконують призначення зліва направо

###  {#slide-id3 data-menu-title="c() та < -"}

Стандартні `<-`, `<<-` та `=` виконують призначення справа наліво

```{r}
a <- b <- c <- 6
print(a)

print(c(a, b, c))
```

`<-` не "створює об'єкт **x** зі значенням **n**", натомість `<-`:

-   Створює об'єкт - вектор, що містить у собі певні значення **n**
-   Прив'язує цей об'єкт до імені **x**

З цим пов'язані деякі неочевидні властивості алокації пам'яті під об'єкти

```{r}
# install.packages("lobstr")
x <- c(1, 2, 4)
lobstr::obj_addr(x)

y <- x
lobstr::obj_addr(y)
```

. . .

**y** не містить у собі копію **x**, два імені є прив'язаними до одного й того ж самого об'єкту у фізичній пам'яті комп'ютера

###  {#slide-id4 data-menu-title="c() та < -"}

```{r}
x[[3]] <- 3
lobstr::obj_addr(x) # нова адреса 

lobstr::obj_addr(y) # продовжує вказувати на стару адресу

print(x) # змінився
print(y) # все ще містить первісне значення 
```

При спробі модифікації об'єкта пов'язаного з іменем **x** було створено його копію, змінено, після чого ім'я **x** було прив'язано до новоствореної копії об'єкту — це є [copy-on-modify behaviour]{.emphasized}. Ця поведінка є характерною для абсолютної більшості об'єктів R.

Виключеннями є середовища та об'єкти з єдиною прив'язкою які виявляють [modify-in-place bahaviour]{.emphasized} (що можна протестувати при взаємодії з нативним CLI R, результати отримані при інтерактивній взаємодії з консолью RStudio не відповідають дійсності через технічні особливості відеозображення об'єктів у панелі середовища)

Дізнатися чи відбувається копіювання певного об'єкту при виконанні якоїсь дії можна шляхом виклику `tracemem(x)`, де **x** є відповідним об'єктом інтересу.

Докладніше про різницю між об'єктом та його іменем, copy-on-modify та modify-in-place поведінкою для векторів та інших структур можна прочитати у [другому розділі Advanced R, “Names and values”](https://adv-r.hadley.nz/names-values.html#names-values)

### Синтактичні імена

Об'єкти є зв'язаними з іменами і дані імена мають слідувати певним правилам, ім'я об'єкту у R може включати у себе літери, цифри, знак `.` та `_` , але не може починатися із цифри або `_` . Імена також не можуть дублювати т.з. зарезервовані слова, повний список яких можна переглянути викликавши `help("Reserved")`

Що вважається за "літери" насправді визначається вашою локальною машиною, що дозволяє мені зробити наприклад так:

```{r}
єґї <- "hi from Ukraine"
print(єґї)
```

На практиці, аби уникнути проблем з передачею даних між комп'ютерами варто обмежитися використанням літер латиниці AZaz, що кодуються ASCII

[Обійти правила синтактичного іменування можливо використавши зворотні лапки]{.emphasized} :

```{r}
`_bad name` <- "Just don't do things like this"
print(`_bad name`)
`if` <- "Don't do things like that either"
print(`if`)
```

Ви майже гарантовано зустрінетесь з не-синтактичними іменами при обробці даних

### Арифметичні оператори

R має стандартний набір операторів для виконання арифметичних дій над чисельними або комплексними векторами або об'єктами, що можуть бути перетвореними на них. За деталями щодо точності виконуваних операції та подібним до `help("Arithmetic")`

```{r}
#| eval: false
x + y
x - y
x * y
x / y
x ^ y   # можливо також використання синтаксису типу x ** y
x %% y  # modulo operation, повертає залишок від ділення
x %/% y # повертає цілу частину від ділення, округлення у меншу сторону
```

. . .

Найбільш класичний приклад використання modulo operation, визначення чи є число парним

```{r}
is_even <- function(x) {
  if (x %% 2 != 0) {
    cat("No,", x, "is an odd number")
  } else {
    cat("Yes,", x, "is an even number")
  }
}

is_even(5)

is_even(2)
```

### Базові математичні функції

```{r}
#| eval: false
sqrt(x) # квадратний корінь
abs(x)  # абсолютне значення

cos(x) sin(x) tan(x) # та інші тригонометричні функції 

sum(...) prod(...) # сума та продукт
min(...) max(...)  # мінімальне та максимальне значення 

cumsum(x) cumprod(x) # кумулятивна сума та продукт
cummin(x) cummax(x)  # мініма та максима

log(x, base = exp(1)) log10() log2() # логарифми

round(x, digits = n) signif(x, digits = n) # округлення значень
trunc(x) floor(x) ceiling(x)
```

\

```{r}
sum(1, 5, 10) # ... символізує, що ця функція може приймати довільну кількість аргументів
cumsum(c(1, 5, 10)) # ця функція приймає лише один аргумент, зверніть увагу на використання c()

# різниця між round() та signif()
round(0.005765, 3) 
signif(0.005765, 3) # зверніть увагу що 5 округлюється у меншу сторону
```

### Бінарні логічні та реляційні оператори

Логічні оператори — `help("Logical")`

```{r}
#| eval: false
!x     # NOT, логічна негація

x & y  # AND, кон'юнкція
x && y 

x | y  # OR, диз'юнкція
x || y

xor(x, y) # elementwise exclusive OR, виняткова диз'юнкція

isTRUE(x)
isFALSE(x)
```

**Для роботи з даними використовуються `&` та `|`**, що виконують обчислення зліва направо, над кожним елементом, доки не буде визначено результат. Оператори `&&` та `||` виконують дії виключно з векторами довжиною один, повертають одне логічне значення та обчислюють по short-circuit, тому використовуються для написання програмних конструкцій

. . .

```{r}
!(TRUE & FALSE) # правило де Моргана
!(TRUE | FALSE)

TRUE & (FALSE | TRUE) # дистрибутивність операцій
TRUE | (FALSE & TRUE)
```

### Бінарні логічні та реляційні оператори

Реляційні оператори — `help("Comparison")`

```{r}
#| eval: false
x < y
x > y
x <= y
x >= y
x == y # еквівалентні
x != y # не еквівалентні
```

\
Функції `any(...)` та `all(...)` перевіряють чи є хоча б одне значення істинними та чи є усі значення істинними відповідно, завжди повертають логічний вектор довжиною 1

```{r}
c(0, 2, 2, 1) > 0

any(c(0, 2, 2, 1) > 0)
all(c(0, 2, 2, 1) > 0)
```

Функція `identical(x, y)` є способом перевірки чи є два значення ідентичні, буквально:

```{r}
1 == 1L          # 1.00 дійсно є еквівалентним 1, але...
identical(1, 1L) # це два різних типи чисельних значень - double та integer
```

### Оператори сетів

`help("sets")`

```{r}
#| eval: false
union(x, y)     # союз
intersect(x, y) # перетин
setdiff(x, y)   # різниця (асиметрична)
setequal(x, y)  # чи є сети рівнозначними

is.element(el, set) # чи належить елемент сету, ідентично команді x %in% y
```

```{r}
x <- 1:6
y <- 4:10

union(x, y)
intersect(x, y)
setdiff(x, y)
setequal(x, y)
is.element(c(1, 4, 10), x)
"a" %in% y

# можливо менш очевидний приклад рівнозначності сетів
setequal(c(1, 1, 0), c(TRUE, TRUE, FALSE))
```

### Bevare of float

```{r}
x <- 2
y <- 2
x == y

y <- sqrt(y)^2
y

x == y # ???
```

. . .

[TL;DR Стиснення нескінченної кількості дійсних чисел у кінцеву кількість бітів вимагає наближеного представлення]{.emphasized}^[пряма цитата](https://dl.acm.org/doi/10.1145/103162.103163)^ Єдиними числами, що є точно представленими у числовому типі R, є цілі числа та дроби, знаменник яких є степенем 2, усі інші типово округлюються до ≈ 53 знаків після коми, що неминуче веде до помилки округлення

```{r}
print(y, digits = 20)
```

У так випадках для порівняння чисельних значень варто використовувати `all.equal(target, current, ...)`, що має певний рівень толерантності до помилки

```{r}
all.equal(x, y) # забігаючи наперед, також можливо використовувати dplyr::near()
```

Якщо 53 знаки після коми не достатньо, то арифметичні операції довільної точності над числами з плаваючою комою можуть бути виконані за допомогою пакета [Rmpfr](https://CRAN.R-project.org/package=Rmpfr)

### Деякі статистичні функції

Базовий пакет `stats`, раджу окремо переглянути індекс документації цього пакету, щоб побачити що ще є

```{r}
#| eval: false
mean(x) sd(x)  # центральна тенденція - середнє та стандартне відхилення
mean(x) mad(x) # центральна тенденція - медіана та медіана абсолютних відхилень

quantile(x, probs) # квантиль, дефолтно повертає 0% 25% 50% 75% 100%
fivenum(x) # п’ятизначний підсумок Тьюкі
IQR(x)     # інтерквантильний розмах
range(...) # мінімум та максимум 

cor(x, y) cov(x, y) var(x) # кореляція, коваріація та варіація
```

Також доступними є низка статистичних тестів та моделей, зокрема:

```{r}
#| eval: false
t.test(x, ...) wilcox.test(x, ...) # Критерій Стьюдента та Уілкоксона/Мєнна-Уітні
pairwise.t.test(x, g) pairwise.wilcox.test(x, g)

p.adjust(p, method) # корекція p-значень при багатократних порівняннях
TukeyHSD(x)         # корекція p-значень методом Тьюкі при парних порівняннях

kruskal.test(x, g, ...) # Критерій Краскал-Уолліса
aov(formula, data)      # дисперсійний аналіз, тип І

lm(formula, data)  # лінійна модель
glm(formula, data) # генералізована лінійна модель
```

### Build-in Constants

Окрім наборів даних, що йдуть з пакетом `datasets`, а також кожною другою бібліотекою R має:

\
вбудований алфавіт латиниці

```{r}
letters
LETTERS
```

назви місяців

```{r}
month.abb
month.name
```

та число $\pi$

```{r}
pi
```

### Генерація регулярних сиквенсів

Найпростіший метод отримати чисельну послідовність від i до j є використання `:` (двокрапки)

```{r}
1:10
10:1
-(1:10)
```

Послідовність від i до j з кроком у n можна отримати командою `seq(...)`

```{r}
seq(from = 1, to = 10, by = 1) # теж що і 1:10
seq(0, 12, 4) # від 0 до 12 з кроком 4
seq(1, 10, length.out = 5) # відома бажана довжина, автоматично визначений крок
```

Послідовність із повторюваних елементів можна отримати командою `rep(x, ...)`

```{r}
rep(10, 3)
rep(c("a", "b", "c"), times = 3) # усю послідовність n разів
rep(c("a", "b", "c"), each = 3)  # кожен елемент послідовності n разів
```

### Статистичні розподіли та випадкові числа

Усі таблиці розподілів у пакеті `stats` можна переглянути викликавши `help("Distributions")`, у залежності від префіксу при виклику назви функції розподілу буде повернено:

-   `dxxxx` — щільність розподілу, перший аргумент квантиль *x*
-   `pxxxx` — кумулятивну щільність розподілу, перший аргумент квантиль *q*
-   `qxxxx` — квантиль функції, перший аргумент вірогідність *p*
-   `rxxxx` — симуляцію функції, перший аргумент вибірка *n*

Кожна функція також має свої специфічні параметри. Наприклад функція нормального розподілу $N(\mu,\sigma^2)$ має параметр математичного очікування $\mu$ та дисперсії випадкової величини $\sigma^2$. Функція нормального розподілу R `*norm()` має дефолтні значення `norm(mean=0, sd=1)`, що відповідають **стандартному нормальному розподілу** $N(0, 1)$

```{r}
dnorm(c(-1, 0, 1))       # Pr(x = a)
pnorm(c(-1, 0, 1))       # Pr(x =< a)
pnorm(1, lower.tail = F) # Pr(x > a)
qnorm(0.5)
rnorm(5)
rnorm(5, mean = 5, sd = 0.5)
```

### Статистичні розподіли та випадкові числа

Симуляція біномінального розподілу може бути дещо більш криптичною на перший погляд. Функція біномінального розподілу $B(n, p)$ має параметр $n$, що відповідає кількості спроб та $p$, що відповідає вірогідності успіху спроби. У біномінальній функції R параметру $n$ відповідає аргумент функції `size`:

```{r}
rbinom(n = 1, size = 1, prob = 0.5)   # окремий випадок біном розподілу - розподіл Бернуллі 

rbinom(n = 1, size = 10, prob = 0.5)  # один повтор, десять спроб
rbinom(n = 10, size = 1, prob = 0.5)  # десять повторів по одній спробі
rbinom(n = 10, size = 10, prob = 0.5) # десять повторів, кожен по десять спроб
```

**Для того, щоб звернутися до документації конкретної функції розподілу, необхідно викликати назву цієї функції з одним із доступних префіксів**, наприклад `?dt` для розподілу Стьюдента. Деякі інші корисні розподіли:

-   `dunif` - рівномірний розподіл
-   `dpois` - розподіл Пуасона
-   `dmultinom` - мультиноміальний розподіл
-   `dgeom` - геометричний розподіл

### Статистичні розподіли та випадкові числа

Отримати випадковий елемент з певного сету можливо за допомогою `sample(x, size)`

```{r}
sample(100, 5)
sample(c("a", "b", "c"), 5, replace = TRUE)
sample(c("a", "b", "c"), 5, replace = TRUE, prob = c(.9, .05, .05))
```

\

. . .

[Генерація випадкових чисел надто важлива, щоб залишати її напризволяще.\*]{.emphasized}\
Якщо Ви колись щось читали про рандомні числа, Ви вірогідно вже знаєте, що усе представлене вище насправді є псевдорандомними числами згенерованими по певному алгоритму. Тому у випадку використання симуляції у своїх розрахунках Вам необхідно заздалегідь назначити `seed`, що забезпечить відтворюваність даних.

::: aside
\*назва публікації Coveyou, R.R. (1969), що формально стала цитатою
:::

```{r}
set.seed(42069)

sample(c(letters, LETTERS), 10, replace = T)
```

За деталями про те як працює RNG у R до `help("Random")`, якщо Вам необхідна якась особлива схема рандомізованої вибірки для експерименту зацініть бібліотеку [sampling](https://CRAN.R-project.org/package=sampling)

### NA, NaN, Inf, та NULL

`NULL` є репрезентацією null-об'єкту, завжди має довжину `0` та не може мати жодних атрибутів. Ви можете зустріти `NULL` як дефолтне значення аргументу деяких функцій, наприклад у функції `seq()` дефолтні значення аргументів `length.out` та `along.with` є `NULL` — це означає, що дані аргументи є *опціональним*, але при їх виклику будуть виконані певні додаткові розрахунки

```{r}
c() 
```

`Inf` та `-Inf` репрезентують +/- нескінченність відповідно, `NaN` репрезентує значення **N**ot **a** **N**umber. І з тим і іншим зазвичай можна зіштовхнутися виконуючи математичні операції

```{r}
0 / 0
log(0)
1 + Inf

c(-1, -Inf, Inf, NaN) < 0 # зверніть увагу, що порівняння з NaN дає NA
```

### NA, NaN, Inf, та NULL

`NA` означає **N**on **A**vailable або **N**ot **A**pplicable — репрезентація відсутності значення на певній позиції. `NA` є логічною константою довжиною один, хоча у різних типах векторів `NA` завжди відображується як `NA`, формально існує своє `NA` для кожного типу вектору окрім `raw`

```{r}
c("a", NA, NA) # зверніть увагу, що NA без лапок
c(NA, 5, 7)
c(TRUE, NA, FALSE)
```

Недетерміноване значення логічно повертає недетермінований результат

```{r}
c(1, -2, NA) > 0 

all(c(NA, 2, 4) > 0) 
any(c(NA, 2, 4) > 0) # але

```

### NA, NaN, Inf, та NULL

Внаслідок цього низка математичних та статистичних функцій будуть повертати `NA` у випадку якщо `NA` присутні у ваших даних

```{r}
set.seed(12345)
x <- sample(c(runif(10), rep(NA, 10)), 10)

mean(x)
sum(x)
```

Виправити це можливо змінивши дефолтне значення аргументу `na.rm`, що властивий багатьом функціям, на `TRUE`

```{r}
mean(x, na.rm = TRUE)
sum(x, na.rm = TRUE)
```

Перевірити чи є якесь значення `NA` можливо викликом `is.na()`, що повертає вектор логічних значень

```{r}
is.na(x)
anyNA(x)
```

### Векторизація та ресайклінг

Висока ефективність та інтуїтивність роботи з даними на R досягається можливістю векторизації низки базових математичних та логічних операцій, що дозволяє уникати написання циклів

[Векторизація забезпечує виконання операції для кожного елементу вектору]{.emphasized}:

```{r}
x <- c(1, 2, 3)
x + 1 # до елементу x[[i]] додати 1
```

У випадку двох векторів довжина яких є рівною та більшою за 1 операція буде виконуватися попарно:

```{r}
x <- c(1, 2, 3)
y <- c(2, 4, 6)
x * y # елемент x[[i]] помножити на елемент y[[i]]
```

Якщо вектори мають різну довжину над коротшим вектором буде проведено [ресайклінг]{.emphasized}, умовно кажучи, його буде подовжено до розміру довшого вектору для виконання операції:

```{r}
x <- c(1, 2, 3, 4)
y <- c(1, 0) 
x * y # імпліцитно y буде перероблено як (1, 0, 1, 0)

y <- c(1, 0, 2) 
x * y # імпліцитно y буде перероблено як (1, 0, 2, 1), попередження у консолі 
```
