---
title: "base R, pt.2"
format: 
  revealjs:
    css: custom.css
    slide-level: 3
    slide-number: c/t
    progress: false
    fig-format: svg
    fig-width: 6
    code-copy: true
execute: 
  echo: true
highlight-style: pygments
knitr: 
  opts_chunk:
    comment: "#>"
    collapse: true
link-external-icon: true
---
### Рідлист

* [Impatient R (Patrick Burns)](https://www.burns-stat.com/documents/tutorials/impatient-r/) — якщо все, що було описано у минулій та цій презентації  залишається криптичним та незрозумілим, максимально стисло та просто про самі основи
* [The R Inferno (Patrick Burns, 2011)](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) — про common R pitfalls, лінк на .pdf файл

### Вектори TL;DR

[Вектор є базовим типом структури у R]{.emphasized}. Скаляри насправді є вектором з довжиною один.

Вектори бувають:

-   атомарні, що містять гомогенні **дані одного** типу
    -   `character` — текстові значення, мають бути заключені у " " або ' '
    -   `logical` — логічні значення
    -   `integer` — цілочислові значення
    -   `double` — число з плаваючою комою (у панелі середовища відображено як `numeric`)
    -   `complex` — комплексне число типу n + i
    -   `raw` — для представлення "сирої" послідовності байтів
-   листи, що можуть містити гетерогенні **дані різних** типів та інші листи

Cтворити пустий вектор можливо командою `vector()` або командою, що відповідає одному з типів описаних вище, визначити тип командою `typeof()`, визначити довжину командою `length()`

```{r}
x <- vector(mode = "logical", length = 0L) # теж саме що x <- logical(length = 0L)
typeof(x)
length(x)
```

###  {#slide-id1 data-menu-title="Вектори TL;DR"}

\
Чотири основні типи векторів, `complex` та `raw` зустрічаються відносно рідко і не показані тут

```{r}
char <- c("This is a String", "This is a second String")
print(char)
typeof(char)
length(char) # зверніть увагу на довжину, вектор містить два елементи

int <- 1:3 
typeof(int)
also_int <- c(1L, 2L, 3L) # суфікс L експліцитно означає цілочислові значення
typeof(also_int)

dbl <- c(1.00, 2.5, 0.0002) 
typeof(dbl)
also_dbl <- c(1, 2, 3)
typeof(also_dbl)

logic <- c(TRUE, FALSE) # R також допускає скорочення T та F
typeof(logic)
```

###  {#slide-id2 data-menu-title="Вектори TL;DR"}

Оскільки атомарні вектори можуть містити лише об'єкти одного типу, при конкатенації векторів різних типів буде виконана спроба конверсії одного типу у інший

Об'єднання будь-якого типу з типом `character` конвертує значення у текстові:

```{r}
new_vector <- c(char, logic, dbl)
print(new_vector)
typeof(new_vector)
```

Об'єднання типу `logical` з чисельними значеннями конвертує логічні значення у чисельні:

```{r}
c(logic, int)
c(TRUE, TRUE, 5, FALSE, FALSE)
```

Об'єднання типу `integer` з `double` дає `double`. Як факт, виконання будь-яких математичних операції між `integer` та `double` поверне значення у форматі `double`:

```{r}
typeof(1L + 2)
```

Окрім того, R здатен зберігати у форматі `integer` лише значення від -214 748 3647 і до 214 748 3647, `x <- 2147483648L` буде збережено як `double` з відповідним попередженням

###  {#slide-id3 data-menu-title="Вектори TL;DR"}

Спробувати "насильно" перевести вектор з одного типу до іншого, або перевірити чи є вектор вектором конкретного типу можливо командою `as.*(x, ...)` та `is.*(x)` де `*` замінено на відповідний тип

```{r}
x <- c(TRUE, FALSE)
is.double(x)
as.double(x)

as.logical(c("true", "F", "bbbb")) # у випадку неможливості конверсії дає NA
```

\
Функції `numeric()` та `as.numeric()` дають такий же результат як `double()` та `as.double()`, **проте `is.numeric()` загалом перевіряє чи може об'єкт бути інтерпретований як чисельний**

```{r}
is.numeric(1)
is.numeric(1L)
is.double(1L)
```

### Перетворення логічних векторів

Так як логічні значення `TRUE` та `FALSE` мають загальноприйняті відповідні їм чисельні значення `1` та `0`, значна кількість функцій, що виконують дії над чисельними векторами здатні також приймати вектори логічні, автоматично перетворивши їх\

Це дозволяє робити так:

```{r}
set.seed(5839)
logic <- sample(c(TRUE, FALSE), 623, replace = TRUE)

mean(logic)

sd(logic)

sum(logic)
```

### Іменовані вектори

Елементи у векторах можуть мати імена, які можуть бути присвоєні безпосередньо при створенні

```{r}
named_vec <- c(a = 1, b = 2, c = 3)
named_vec
```

Або для вже інсуючого вектору, командою `names(x) <-` або `setNames()`

```{r}
names(named_vec) <- c("a", "b", "c")
named_vec
named_vec <- setNames(named_vec, c("x", "y", "z"))
named_vec
```

Переглянути імена елементів об'єкту, його інші атрибути та структуру можливо наступними командами:

```{r}
str(named_vec) # структура об'єкту
attributes(named_vec) # атрибути об'єкту
attr(named_vec, "names") # тільки імена
```

### Листи

Пустий лист бажаної довжини також може бути створений командою тією ж командою `vector()`

```{r}
empty_ls <- vector(mode = "list") 
empty_ls # пустий лист довжиною 0
```

Сконструювати лист можливо командою `list(...)`

```{r}
some_ls <- list(c(1, 2, 3), 5.0, "a")
some_ls

other_ls <- list(nums = 1:3, lettrs = c("a", "a", "b"), logic = T)
other_ls
```

###  {#slide-id4 data-menu-title="Листи"}

Лист може мати лист у середні себе

```{r}
bottomless_pit <- list(
  another_list = list(
   and_other_list = list(
    and_other_other_list = list(
      and_other_other_other_list = list(
       look_inside = "not bottomless",
       pit = "just regular pit now"
      )))))

bottomless_pit
```

. . .

```{r}
length(bottomless_pit)
str(bottomless_pit)
```

### Сабсетинг векторів

[Сабсетинг]{.emphasized} — "витягування" певного елементу структури, може бути виконане у шість різних способів із застосуванням трьох різних операторів, `[`, `[[` та `$` та може бути комбіноване з `<-`

**Оператори `[[` та `$` повертають єдиний елемент.** Оператор `$` не допускається до використання з атомарними векторами, але для інших структур може використовуватися для доступу до єлементу по імені

Найпростіший варіант сабсетингу вектору — по індексу (позиції) елементу, позитивним цілим числом:

```{r}
vec <- c(2.1, 5.2, 2.3, 1.4)
vec[[3]] # повернути елемент у позиції 3
vec[3]   # для атомарних векторів [i] та [[i]] фактично дають однаковий результат

vec[1:3]     # елементи з позиції 1 по 3
vec[c(2, 4)] # елемент у позиції 2 та 4

# менш інтуїтивні приклади 
vec[c(4, 2, 1)]
vec[c(2, 2, 2, 2, 2)]
```

###  {#slide-id5 data-menu-title="Сабсетинг векторів"}

Сабсетинг негативним цілим числом повертає усі елементи крім вказаного:

```{r}
vec[-3]
vec[-c(1, 3)] # теж саме що vec[c(-1, -3)]
vec[-c(1:3)]
```

Сабсетинг текстом дозволяє витягнути елемент по його імені:

```{r}
names(vec) <- c("one", "two", "three", "four")

vec[["two"]]
vec[c("one", "one")]
```

```{r}
#| include: false
vec <- unname(vec)
```

Сабсетинг логічними значеннями повертає елементи позиція яких відповідає значенню TRUE:

```{r}
vec[c(TRUE, FALSE, TRUE, FALSE)]
vec[c(FALSE, TRUE)] # ресайклінг до FALSE TRUE FALSE TRUE

vec[TRUE]
vec[[TRUE]]
```

###  {#slide-id6 data-menu-title="Сабсетинг векторів"}

Ніщо повертає оригінальний вектор:

```{r}
vec[]
```

Нуль повертає вектор довжиною нуль:

```{r}
vec[0]
```

Об'єкт, що подається до `[` є звичайним вектором, що дозволяє використовувати для сабсетингу значення, що зберігаються у інших векторах, подавати до `[` функції, якщо дані функції повертають вектор логічного, чисельного чи текстового типу та виконувати у `[` логічні та арифметичні операції:

```{r}
y <- c(1, 2, 2, 3, 4)
vec[y]

vec[2+2]
```

Як вже було зазначено, можливо використовувати сабсетинг разом із `<-`

```{r}
vec[[4]] <- 10  
vec[[5]] <- 5.5 
vec
vec[[1]] <- "a"
vec
```

### `which()` та деякі інші команди

Функція `which(x)` повертає **індекс** елементів вектору, що задовольняють вказану логічну умову:

```{r}
set.seed(2312)
x <- sample(100, 10)
x

which(x > 10 & x < 35)
which.max(x)
which.min(x)
```

Низка інших функцій для роботи з векторами

```{r}
order(x) # повертає індекси сортованого вектору
sort(x)  # повертає сортований вектор
rev(c(3, 10, 1)) # перегортає вектор
unique(rep(letters[5:9], 10)) # повертає унікальні значення
table(rep(letters[5:9], 10))  # крос-табуляція, докладніше пізніше 
```

### Сабсетинг листів

Майже як вектори, але `[` завжди повертає структуру типу лист

```{r}
example_ls <- list(a = "a", b = 1:3, c = list("One", 2))
example_ls[1]
example_ls[3]
typeof(example_ls[3])
typeof(example_ls[1])
```

Оператор `[[` повертає єдиний елемент з відповідним типом

```{r}
example_ls[[1]]   # референсинг по індексу
example_ls[["b"]] # референсинг по імені
typeof(example_ls[[1]])
typeof(example_ls[["b"]])
```

###  {#slide-id7 data-menu-title="Сабсетинг листів"}

```{r}
example_ls[["c"]] 
typeof(example_ls[["c"]])
example_ls[["c"]][[1]]
typeof(example_ls[["c"]][[1]])
```

Оператор `$` фактично є скороченням оператору `[[` для доступу по імені

```{r}
example_ls$a
example_ls$c[[2]]
```

Як і у випадку з атомарним вектором, `<-` може бути використано для заміни або додавання елементів, окрім того `<-` може бути комбіноване з `NULL` для видалення елементу листа

```{r}
example_ls$c <- NULL       # це видалить елемент
example_ls$w <- list(NULL) # а це буквально додасть елемент зі значенням NULL
```

### Матриці

Прямокутні структури, що мають колонки та рядки. Фактично є векторами, що мають атрибут розмірності `dim`. Як і атомарні вектори, матриці можуть містити дані лише одного типу.

Створення матриці командою `matrix()`, дефолтно матриця будується по колонкам

```{r}
m <- matrix(c(1, 2, 3,
              1, 2, 3,  # вказати кількість колонок або рядків, базове значення 1          
              1, 2, 3), nrow = 3) 
m
```

Можливо вказати `byrow=TRUE`, щоб матриця була побудована по рядках

```{r}
m <- matrix(c(1, 2, 3,
              1, 2, 3,           
              1, 2, 3), nrow = 3, byrow = TRUE) 
m
```

### Матриці

```{r}
attributes(m) # матриця 3х3
dim(m)
nrow(m) # кількість рядків
ncol(m) # кількість колонок
```

Звичайний атомарний вектор не має просторової розмірності взагалі

```{r}
n <- 1:9
dim(n)

dim(n) <- c(1, 9) # тепер має
n

dim(n) <- c(3, 3)
n
```

### Матриці

Так як матриці є векторами у розумінні R звичайні арифметичні та логічні операції дають такий самий результат як з векторами

```{r}
m * n # елемент n[i, j] буде помножено на елемент m[i, j]
```

\
Для виконання дій лінійної алгебри є низка своїх операторів, зокрема `%*%` для множення матриці

```{r}
m %*% n
```

\

```{r}
#| eval: false
crossprod(X, Y = NULL) # крос-продукт
tcrossprod(X, Y = NULL)
outer(X, Y) # зовнішній продукт
%o%
```

### Матриці

Матриця може бути транспонована командою `t(x)`

```{r}
t(n)
```

Колонки та рядки матриці можуть мати імена, які можуть бути встановлені відповідно командами `colnames()` та `rownames()`, аналогічно `names()` для векторів. Додати нову колонку або рядок до матриці можливо застосуванням `cbind()` та `rbind()`

```{r}
n <- cbind(n, c(0, 0, 0))
rownames(n) <- LETTERS[1:3]
colnames(n) <- letters[1:4]
n
```

### Сабсетинг матриць

Як вектори, але мають додатковий вимір, тому у `[` ідуть два значення, перше вказує на рядок, друге на колонку

```{r}
n[[2, 3]] # другий елемент третьої колонки
n[1:2, 1:2]
n[2, ]  # другий рядок повністю 
n[ ,3]  # третя колонка повністю 
n[, 3, drop = FALSE] # збереження розмірності

typeof(n) # матриця не є типом, як не дивно
class(n)
class(n[, 3])
class(n[, 3, drop = FALSE]) 
```

###  {#slide-id8 data-menu-title="Сабсетинг матриць"}

*P.s* Ви могли помітити, що об'єкт окрім класу `matrix` також мав клас `array` — масив. Окрім двомірних матриць можливо створювати структури вищої розмірності. Сабсетинг такий самий, просто з оглядом на додаткові виміри

```{r}
arr <- array(1:18, c(3, 3, 2)) # простий приклад, може бути гірше
arr

arr[1, 3, 2]
```

### Кадри даних (Data Frames)

Прямокутні структури, що мають колонки та рядки. Подібні за властивостями до листів, фактично кажучи колонки кадрів даних і є векторами листів — таким чином *колонки* мають включати у себе об'єкти одного типу, у той час як *рядки* можуть містити об'єкти різних типів.

Створити кадр даних можливо командою `data.frame()`, вказавши імена та значення для колонок:

```{r}
df <- data.frame(
  char = c(letters[1:4]),
  int = 1:4,
  dbl = runif(4))
df
```

Краще зрозуміти як можуть виглядати кадри даних можливо через ознайомлення з класичними датасетами представленими у R, наприклад `mtcars` або `iris`. Або взяти щось менш популярне.

```{r}
data(crabs, package = "MASS") # це експліцитно завантажить ці данні у Ваш робочій простір
#?MASS::crabs щоб дізнатися більше про набір даних 
```

Щоб інтерактивно переглянути кадр даних у більш звичному стилі електронної таблиці викличте `View(x)`

### Кадри даних

Швидке знайомство з кадром даних можливо провести переглянувши декілька перших рядків у консолі

```{r}
head(crabs, n = 5)
```

Або краще, переглянувши його структуру

```{r}
str(crabs)
```

### Кадри даних

Для приєднання нових колонок / рядків використовуються ті ж команди, що і у випадку матриці

```{r}
colnames(crabs) <- c(colnames(crabs)[1:3], "front_lobe", "rear_wd", 
                  "carapace_l", "carapace_wd", "body_depth")
crabs <- cbind(crabs, species = rep("crab", nrow(crabs)))

head(crabs, 5)
```

Сабсетинг є дещо міксом між матрицями та листами, але зазвичай це не стає проблемою

```{r}
small_crabs <- head(crabs, n = 3) # маленький шматок для демонстрації
```

### Сабсетинг кадрів даних

```{r}
small_crabs[4:9]   # колонки з 4 по 9, сабсетинг як лист
small_crabs[, 4:9] # теж саме, сабсетинг як матриця
small_crabs[2, 1:4]

str(small_crabs["index"])   # зберігає структуру
str(small_crabs[, "index"]) # симліфікація до атомарного вектору, як і у випадку матриці
str(small_crabs[, "index", drop = FALSE])
str(small_crabs$index) # також дроп структури
```

### Сабсетинг кадрів даних

```{r}
typeof(small_crabs["index"]) # можна впевнитися, що колонки кадрів дійсно є листами

# як і з листами, NULL можна використати, щоб видалити колонку
small_crabs$species <- NULL
small_crabs

# так само додати нову
small_crabs$new_val <- NA # NA для прикладу, сюди можна присвоїти значення одразу
small_crabs

# базове практичне застосування з іншими функціями
mean(small_crabs$rear_wd)
max(small_crabs$front_lobe)
```

```{r}
#| include: false
data(crabs, package = "MASS")
```

### `factor` та деякі інші S3-вектори

Вектори можуть мата атрибут `class`, що перетворює їх на S3-об'єкти, при передачі таких об'єктів до generic-функцій для їх обробки буде викликано метод специфічний конкретному класу.

Фактори — `factor` — є репрезентацією категоріального типу даних з певним **фіксованим** набором рівнів. Кожен рівень фактору є кодованим цілочисловим значенням. Якщо знову переглянути структуру датасету `crabs` то можна побачити, що перша та друга колонка значаться як `Factor w/ 2 levels` з числовими значеннями.

Колонка `crabs$sex`, що містить дані про стать особини, є *категоріальним* типом даних з двома можливими рівнями F та M, що відповідно кодовані числами 1 та 2 у структурі кадру даних

```{r}
levels(crabs$sex)
class(crabs$sex)
```

\
"Здерти" атрибут класу можливо функцією `unclass(x)`, що може дозволити більш явно побачити, що **структура фактору є надбудовою над вектором типу** `integer`

```{r}
typeof(crabs$sex)
```

### `factor` та деякі інші S3-вектори

Фактори можуть бути конвертовані до звичайного вектору типу `character` та навпаки. Фактор може бути створено відповідною командою `factor()`

```{r}
crustacea <- factor(c("crab", "shrimp", "shrimp"))
crustacea

crustacea <- factor(c("crab", "shrimp", "shrimp"), levels = c("crab", "shrimp", "krill"))
crustacea
```

\
Команда `table()`, що повертає об'єкт відповідного класу `table`, використовує перехресну класифікацію факторів для побудови **таблиці спряженості** (contingency table) — таблиці, яка відображає багатофакторний частотний розподіл змінної

```{r}
table(crustacea)
```

### `factor` та деякі інші S3-вектори

Працюючи з даними також можливо зустрітися з класами векторів що є репрезентацією часу:

-   `Date` — репрезентація дати
-   `POSIXct` та `POSIXlt` — репрезентація дати-часу
-   `difftime` — репрезентація проміжку часу

::: aside
\*POSIX означає Portable Operating System Interface, ct - calendar time та lt - local time
:::

```{r}
Sys.Date()
class(Sys.Date())
Sys.time()
class(Sys.time())

difftime(as.Date("2024-03-04"), as.Date("2024-03-01"))
difftime(as.Date("2024-03-04"), as.Date("2024-03-01"), units = "mins")
```

Усі ці класи є надбудовою над вектором типу `double`

```{r}
typeof(as.Date("2024-03-01"))
```

### Написання функцій

Функція створюється відповідною командою `function(...)` і складається з трьох обов'язкових компонентів — аргументів, тіла та середовища виконання, інформацію про які можна отримати командами `formals()`, `body()` та `environment()` відповідно. Функції зв'язуються зі своїм іменем як і будь-який інший об'єкт

```{r}
fun <- function(a, b, c, x) { # аргументи
  a*x^2 + b*x + c             # тіло функції
}                             # середовище залежить від того, де функція створена
```

\
Імпліцитно функція повертає останній об'єкт, який було отримано у ході виконання коду. Експліцитно вказати які об'єкти мають бути поверненні можливо викликом `return()`

```{r}
fun2 <- function(x, y) {
  x^2
  return(y)
}

fun2(5, 1)
```

### Написання функцій

Прив'язка до імені не обов'язкова, функція може бути анонімною, зазвичай анонімні функції використовуються у середині команд сімейства `apply()` або їх аналогів

```{r}
(function (x) 3^2)()
sapply(1:10, function(x) x^2)
sapply(1:10, \(x) x^2) # скорочення для анонімної функції
```

Функції також можливо організувати у лист:

```{r}
funs <- list(
  square = function(x) x^2,
  cube = function(x) x^3,
  tesseract = function(x) x^4
)

funs$square(2)
funs$cube(2)
funs$tesseract(2)
```

### Lexical scoping та Ліниві обчислення (Lazy evaluation)

У R аргументи функцій обчислюються тільки у випадку безпосереднього звернення до них

```{r}
hello <- function(x) {
  print("Hello")
}

exists("somebody") # об'єкт з такою назвою наразі не існує у середовищі
hello(somebody)    # але функція все одно виконується
```

Модифіковане завдання із SICP (в оригіналі спрямовано на демонстрацію різниці між normal-order та applicative-order evaluation)

```{r}
p <- function() {
  p()
}

test_xy <- function(x, y) {
  if (x == 0) {
    0
  } else {
    y
  }
}

test_xy(0, p())
```

### Lexical scoping та Ліниві обчислення (Lazy evaluation)

Лексичний скоупінг — пошук значень асоційованих з певними іменами, слідує у R таким правилам:

-   **Name masking** — імена визначені усередині функції маскують імена визначені поза функцією
-   **Functions vs variables** — так як функції є звичайними об'єктами, правило маскування імен застосовується і до функцій
-   **Fresh start** — при кожному виклику функції для її виконання створюється нове середовище, тому кожен виклик є незалежним. Функція не зберігає інформації про значення змінних, що були отримані у минулому виклику
-   **Dynamic lookup** — результат кожного нового виклику функції може відрізнятися і залежати від стану об'єктів, що знаходяться поза середовищем виконання функції

Приклад маскування імені, за іншими прикладами до [Advanced R 2ed, Chapter 6.4](https://adv-r.hadley.nz/functions.html#lexical-scoping)

```{r}
x <- 10
y <- 20
fun <- function() {
  x <- "Some string"
  c(x, y)
}

fun()
c(x, y)
```

### Control flow

Докладніше `help("Control)`. У R присутні два типи операторів для контролю потоку

-   оператори вибору — `if` / `else` та `switch()`
-   оператори циклу — `for`, `while` та `repeat`

А також допоміжні оператори для контролю усередині циклу — `next` та `break`.

```{r}
#| eval: false
if (condition) do_something 
if (condition) do_something else do_something_else

for (item in sequence) do_action
while (condition == TRUE) do_action
repeat action

for (item in sequence) {
  if (condition)
    next
  do_action
}
repeat {
  if (condition)
    break
  action
}
```

У R також є низка команд для зворотного діагностичного фідбеку до користувача — `stop()`, `message()` та `warnings()`

### Control flow

Приклад з `if` / `else`

```{r}
#| eval: false
is_even <- function(x) {
  if (x == 0) {
    cat("Not odd, not even:", x, "is zero")
  } else if (x %% 2 != 0) {
    cat("No", x, "is an odd number")
  } else {
    cat("Yes", x, "is an even number")
  }
}
```

Простий приклад `for` ітерації

```{r}
for (i in letters[1:5]) print(i)
for (i in seq_along(letters[1:5])) print(letters[[i]]) # більш надійний варіант
```

### Control flow

Приклад `switch()` — альтернатива `if` / `else` для окремих випадків

```{r}
grade <- function(g) {
  switch(g,
      A = "> 89%",
      B = "75 - 89%",
      C = "60 - 74%",
    `F` = "< 60%",
    stop("Invalid value")
  )
}
grade("B")
```

Варіант якщо декілька вхідних опцій дають однаковий вихід

```{r}
grade_pass <- function(g) {
  switch(g,
      A = ,
      B = ,
      C = "passed",
    `F` = "failed",
    stop("Invalid value")
  )
}
grade_pass("B")
grade_pass("F")
```

### Control flow

::: aside
\*`cat()` виводить об'єкти, об'єднуючи їх репрезентацію, альтернативно тут можна використати `print(paste())` або той же `print(с())`
:::

Функція з `for` циклом

```{r}
for_petri <- function(n) {
  for (i in 1:n) {
    cat("There", if (n == 1) "was" else "were", n, "Petri", if (n==1) "dish." else "dishes.",
    "One fell down. There are", n - 1, "Petri dishes left.\n")
    n <- n-1
  }
}
for_petri(5)
```

Та ж сама функція, але з `while` циклом та векторизованим `ifelse()`

```{r}
#| eval: false
while_petri <- function(n) {
  while (n > 0) {
    cat("There", ifelse(n == 1, "was", "were"), n, "Petri", ifelse(n == 1, "dish.", "dishes."), 
        "One fell down. There are", n - 1, "Petri dishes left.\n")
    n <- n-1
  }
}
```

### Векторизований `ifelse()`

As it says. Бере вхідний вектор значень і повертає вихідний вектор значення якого залежать від задовільненя умови — `ifelse(test_condition, yes, no)`

```{r}
x <- 1:10
ifelse(x %% 2 == 0, "even", "odd")
```

::: aside
\*Пакет dplyr, про який ми будемо говорити у наступний раз, має більш стабільну версію функції — `is_else()`
:::

Здирає атрибути класу, тому вихідні результати інколи можуть бути непередбачуваними. Приклад прямо з документації функції

```{r}
x <- seq(as.Date("2000-02-29"), as.Date("2004-10-04"), by = "1 month")
head(x)
y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)
head(y)
class(y) <- "Date"
head(y)
```

### Сімейство `apply()`
Картує функцію на кожен елемент масиву або листу. Як факт, ці функції є прихованим `for`-циклом. **Коректно** написаний `for`-цикл буде займати приблизно стільки ж часу на виконання скільки функція сімейства `apply()`. 

| функція           | вхід                                                 | вихід                  |
|-----------------|--------------------------------------|-----------------|
| `apply`           | матриця або масив                                    | вектор, масив або лист |
| `lapply`          | лист або вектор                                      | лист                   |
| `sapply`, `vaply` | лист або вектор                                      | вектор, матриця, масив |
| `tapply`          | дані розбиті на групи за комбінацією рівнів факторів | вектор або лист        |
| `mapply`          | листи або вектори                                    | лист, вектор або масив |
| `rapply`          | лист                                                 | вектор або лист        |
| `eapply`          | середовище                                           | лист                   |

: Таблиця \`apply\` функцій

### Сімейство `apply()`
У більшості випадків Вам знадобиться лише `lapply()`, у прикладі нижче насправді можливо використати `apply(crabs[4:8], 2, sd)`, але функція `lapply()` є швидшою

```{r}
rbind(lapply(crabs[4:8], mean)) # для цього насправді є векторизований colMeans()
rbind(lapply(crabs[4:8], sd))
```

\
Інколи для того, щоб швидко перевірити певний групований статистичний підсумок (e.g. середнє певного параметру для кожного рівня конкретного фактору) зручним буває `tapply()`
```{r}
tapply(crabs$FL, crabs$sex, mean)
```

Також існує функція `aggregate()`
```{r}
aggregate(FL ~ sex, crabs, mean)
aggregate(. ~ sex, crabs, mean)
```

### Базова графіка
Базові графічні можливості R насправді є досить широкими, проте (на мою думку) граматика стандартних графічних бібліотек сильно поступається у інтуїтивності граматиці популярного ggplot2

Тим не менш, найпростіші графіки можливо швидко створити за допомогою низки простих коротких команд, що є ідеальним для процесу Explaratory Data Analisys. Команда `plot(x, y)` за умовчанням створює класичну діаграму розсіяння (scatterplot)
```{r}
plot(iris$Sepal.Length, iris$Petal.Length)
```

::: {.column .absolute width="50%" top="280" right="20" height="700"}
Деякі інші команди для виклику графіки

* `hist`
* `pairs`
* `boxplot`
* `barplot`
* `dotchart`
* `mosaicplot` та `spineplot`
* `image`, `contour`, `heatmap`

Також команда `par(...)` для додаткового налаштування параметрів базової графіки
:::

### Базове використання статистичних функцій
Більшість як нативних так і імпортованих функцій працюють з кадрами даних або векторами та використовують синтаксис типу `fun(y ~ x, data, ...)` або `fun(y, x)`, де `y` та `x` є залежною та незалежною змінною (або змінними) відповідно
```{r}
data("PlantGrowth")
kruskal.test(weight ~ group, PlantGrowth)

pairwise.t.test(PlantGrowth$weight, PlantGrowth$group, p.adjust.method = "bonf")
```

### The Pipe
При виконанні ланцюжку команду одну функцію можливо помістити у середину іншої, e. g.
```{r}
aggregate(FL ~ sp, subset(crabs, sex == "M"), mean)
```

Нативний  інфікс оператор `|>` (R 4.1+) або `⁠%>%` з пакету `magrittr` дозволяють створювати ланцюг команд подібного типу, що робить їх більш читабельними
```{r}
crabs |> subset(sex == "M") |> aggregate(FL ~ sp, mean)

library(magrittr)
crabs %>% subset(sex == "M" ) %>% aggregate(FL ~ sp, mean)
```

Конкретна зручність використання `|>` або `⁠%>%` при роботі з даними починає відчуватися при роботі з системою бібліотек `tidyverse`

Про різницю між нативним pipe-оператором та оператором magrittr можна прочитати [тут](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/)