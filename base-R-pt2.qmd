---
title: "base R, pt.2"
format: 
  revealjs:
    css: custom.css
    slide-level: 3
    slide-number: c/t
    progress: false
    fig-format: svg
    fig-width: 6
    code-copy: true
execute: 
  echo: true
highlight-style: breezedark
knitr: 
  opts_chunk:
    comment: "#>"
    collapse: true
link-external-icon: true
chalkboard: true
---

### Вектори TL;DR

[Вектор є базовим типом структури у R]{.emphasized}. Скаляри насправді є вектором з довжиною один.

Вектори бувають:

-   атомарні, що містять гомогенні **дані одного** типу
    -   `character` — текстові значення, мають бути заключені у " " або ' '
    -   `logical` — логічні значення
    -   `integer` — цілочислові значення
    -   `double` — число з плаваючою комою (у панелі середовища відображено як `numeric`)
    -   `complex` — комплексне число типу n + i
    -   `raw` — для представлення "сирої" послідовності байтів
-   листи, що можуть містити гетерогенні **дані різних** типів та інші листи

Cтворити пустий вектор можливо командою `vector()` або командою, що відповідає одному з типів описаних вище, визначити тип командою `typeof()`, визначити довжину командою `length()`

```{r}
x <- vector(mode = "logical", length = 0L) # теж саме що x <- logical(length = 0L)
typeof(x)
length(x)
```

###  {#slide-id1 data-menu-title="Вектори TL;DR"}

\
Чотири основні типи векторів, `complex` та `raw` зустрічаються відносно рідко і не показані тут

```{r}
char <- c("This is a String", "This is a second String")
print(char)
typeof(char)
length(char) # зверніть увагу на довжину, вектор містить два елементи

int <- 1:3 
typeof(int)
also_int <- c(1L, 2L, 3L) # суфікс L експліцитно означає цілочислові значення
typeof(also_int)

dbl <- c(1.00, 2.5, 0.0002) 
typeof(dbl)
also_dbl <- c(1, 2, 3)
typeof(also_dbl)

logic <- c(TRUE, FALSE) # R також допускає скорочення T та F
typeof(logic)
```

###  {#slide-id2 data-menu-title="Вектори TL;DR"}

Оскільки атомарні вектори можуть містити лише об'єкти одного типу, при конкатенації векторів різних типів буде виконана спроба конверсії одного типу у інший

Об'єднання будь-якого типу з типом `character` конвертує значення у текстові:

```{r}
new_vector <- c(char, logic, dbl)
print(new_vector)
typeof(new_vector)
```

Об'єднання типу `logical` з чисельними значеннями конвертує логічні значення у чисельні:

```{r}
c(logic, int)
c(TRUE, TRUE, 5, FALSE, FALSE)
```

Об'єднання типу `integer` з `double` дає `double`. Як факт, виконання будь-яких математичних операції між `integer` та `double` поверне значення у форматі `double`:

```{r}
typeof(1L + 2)
```

Окрім того, R здатен зберігати у форматі `integer` лише значення від -214 748 3647 і до 214 748 3647, `x <- 2147483648L` буде збережено як `double` з відповідним попередженням

###  {#slide-id3 data-menu-title="Вектори TL;DR"}

Спробувати "насильно" перевести вектор з одного типу до іншого, або перевірити чи є вектор вектором конкретного типу можливо командою `as.*(x, ...)` та `is.*(x)` де `*` замінено на відповідний тип

```{r}
x <- c(TRUE, FALSE)
is.double(x)
as.double(x)

as.logical(c("true", "F", "bbbb")) # у випадку неможливості конверсії дає NA
```

\
Функції `numeric()` та `as.numeric()` дають такий же результат як `double()` та `as.double()`, **проте `is.numeric()` загалом перевіряє чи може об'єкт бути інтерпретований як чисельний**

```{r}
is.numeric(1)
is.numeric(1L)
is.double(1L)
```

### Перетворення логічних векторів

Так як логічні значення `TRUE` та `FALSE` мають загальноприйняті відповідні їм чисельні значення `1` та `0`, значна кількість функцій, що виконують дії над чисельними векторами здатні також приймати вектори логічні, автоматично перетворивши їх\

Це дозволяє робити так:

```{r}
set.seed(5839)
logic <- sample(c(TRUE, FALSE), 623, replace = TRUE)

mean(logic)

sd(logic)

sum(logic)
```

### Іменовані вектори

Елементи у векторах можуть мати імена, які можуть бути присвоєні безпосередньо при створенні

```{r}
named_vec <- c(a = 1, b = 2, c = 3)
named_vec
```

Або для вже інсуючого вектору, командою `names(x) <-` або `setNames()`

```{r}
names(named_vec) <- c("a", "b", "c")
named_vec
named_vec <- setNames(named_vec, c("x", "y", "z"))
named_vec
```

Переглянути імена елементів об'єкту, його інші атрибути та структуру можливо наступними командами:

```{r}
str(named_vec) # структура об'єкту
attributes(named_vec) # атрибути об'єкту
attr(named_vec, "names") # тільки імена
```

### Листи

Пустий лист бажаної довжини також може бути створений командою тією ж командою `vector()`

```{r}
empty_ls <- vector(mode = "list") 
empty_ls # пустий лист довжиною 0
```

Сконструювати лист можливо командою `list(...)`

```{r}
some_ls <- list(c(1, 2, 3), 5.0, "a")
some_ls

other_ls <- list(nums = 1:3, lettrs = c("a", "a", "b"), logic = T)
other_ls
```

###  {#slide-id4 data-menu-title="Листи"}

Лист може мати лист у середні себе

```{r}
bottomless_pit <- list(
  another_list = list(
   and_other_list = list(
    and_other_other_list = list(
      and_other_other_other_list = list(
       look_inside = "not bottomless",
       pit = "just regular pit now"
      )))))

bottomless_pit
```

. . .

```{r}
length(bottomless_pit)
str(bottomless_pit)
```

### Сабсетинг векторів

[Сабсетинг]{.emphasized} — "витягування" певного елементу структури, може бути виконане у шість різних способів із застосуванням трьох різних операторів, `[`, `[[` та `$` та може бути комбіноване з `<-`

**Оператори `[[` та `$` повертають єдиний елемент.** Оператор `$` не допускається до використання з атомарними векторами, але для інших структур може використовуватися для доступу до єлементу по імені

Найпростіший варіант сабсетингу вектору — по індексу (позиції) елементу, позитивним цілим числом:

```{r}
vec <- c(2.1, 5.2, 2.3, 1.4)
vec[[3]] # повернути елемент у позиції 3
vec[3]   # для атомарних векторів [i] та [[i]] фактично дають однаковий результат

vec[1:3]     # елементи з позиції 1 по 3
vec[c(2, 4)] # елемент у позиції 2 та 4

# менш інтуїтивні приклади 
vec[c(4, 2, 1)]
vec[c(2, 2, 2, 2, 2)]
```

###  {#slide-id5 data-menu-title="Сабсетинг векторів"}

Сабсетинг негативним цілим числом повертає усі елементи крім вказаного:

```{r}
vec[-3]
vec[-c(1, 3)] # теж саме що vec[c(-1, -3)]
vec[-c(1:3)]
```

Сабсетинг текстом дозволяє витягнути елемент по його імені:

```{r}
names(vec) <- c("one", "two", "three", "four")

vec[["two"]]
vec[c("one", "one")]
```

```{r}
#| include: false
vec <- unname(vec)
```

Сабсетинг логічними значеннями повертає елементи позиція яких відповідає значенню TRUE:

```{r}
vec[c(TRUE, FALSE, TRUE, FALSE)]
vec[c(FALSE, TRUE)] # ресайклінг до FALSE TRUE FALSE TRUE

vec[TRUE]
vec[[TRUE]]
```

###  {#slide-id6 data-menu-title="Сабсетинг векторів"}

Ніщо повертає оригінальний вектор:

```{r}
vec[]
```

Нуль повертає вектор довжиною нуль:

```{r}
vec[0]
```

Об'єкт, що подається до `[` є звичайним вектором, що дозволяє використовувати для сабсетингу значення, що зберігаються у інших векторах, подавати до `[` функції, якщо дані функції повертають вектор логічного, чисельного чи текстового типу та виконувати у `[` логічні та арифметичні операції:

```{r}
y <- c(1, 2, 2, 3, 4)
vec[y]

vec[2+2]
```

Як вже було зазначено, можливо використовувати сабсетинг разом із `<-`

```{r}
vec[[4]] <- 10  
vec[[5]] <- 5.5 
vec
vec[[1]] <- "a"
vec
```

### `which()` та деякі інші команди

Функція `which(x)` повертає **індекс** елементів вектору, що задовольняють вказану логічну умову:

```{r}
set.seed(2312)
x <- sample(100, 10)
x

which(x > 10 & x < 35)
which.max(x)
which.min(x)
```

Низка інших функцій для роботи з векторами

```{r}
order(x) # повертає індекси сортованого вектору
sort(x)  # повертає сортований вектор
rev(c(3, 10, 1)) # перегортає вектор
unique(rep(letters[5:9], 10)) # повертає унікальні значення
table(rep(letters[5:9], 10))  # крос-табуляція, докладніше пізніше 
```

### Сабсетинг листів

Майже як вектори, але `[` завжди повертає структуру типу лист

```{r}
example_ls <- list(a = "a", b = 1:3, c = list("One", 2))
example_ls[1]
example_ls[3]
typeof(example_ls[3])
typeof(example_ls[1])
```

Оператор `[[` повертає єдиний елемент з відповідним типом

```{r}
example_ls[[1]]   # референсинг по індексу
example_ls[["b"]] # референсинг по імені
typeof(example_ls[[1]])
typeof(example_ls[["b"]])
```

###  {#slide-id7 data-menu-title="Сабсетинг листів"}

```{r}
example_ls[["c"]] 
typeof(example_ls[["c"]])
example_ls[["c"]][[1]]
typeof(example_ls[["c"]][[1]])
```

Оператор `$` фактично є скороченням оператору `[[` для доступу по імені

```{r}
example_ls$a
example_ls$c[[2]]
```

Як і у випадку з атомарним вектором, `<-` може бути використано для заміни або додавання елементів, окрім того `<-` може бути комбіноване з `NULL` для видалення елементу листа

```{r}
example_ls$c <- NULL       # це видалить елемент
example_ls$w <- list(NULL) # а це буквально додасть елемент зі значенням NULL
```

### Матриці

Прямокутні структури, що мають колонки та рядки. Фактично є векторами, що мають атрибут розмірності `dim`. Як і атомарні вектори, матриці можуть містити дані лише одного типу.

Створення матриці командою `matrix()`, дефолтно матриця будується по колонкам

```{r}
m <- matrix(c(1, 2, 3,
              1, 2, 3,  # вказати кількість колонок або рядків, базове значення 1          
              1, 2, 3), nrow = 3) 
m
```

Можливо вказати `byrow=TRUE`, щоб матриця була побудована по рядках

```{r}
m <- matrix(c(1, 2, 3,
              1, 2, 3,           
              1, 2, 3), nrow = 3, byrow = TRUE) 
m
```

### Матриці

```{r}
attributes(m) # матриця 3х3
dim(m)
nrow(m) # кількість рядків
ncol(m) # кількість колонок
```

Звичайний атомарний вектор не має просторової розмірності взагалі

```{r}
n <- 1:9
dim(n)

dim(n) <- c(1, 9) # тепер має
n

dim(n) <- c(3, 3)
n
```

### Матриці

Так як матриці є векторами у розумінні R звичайні арифметичні та логічні операції дають такий самий результат як з векторами

```{r}
m * n # елемент n[i, j] буде помножено на елемент m[i, j]
```

\
Для виконання дій лінійної алгебри є низка своїх операторів, зокрема `%*%` для множення матриці

```{r}
m %*% n
```

\

```{r}
#| eval: false
crossprod(X, Y = NULL) # крос-продукт
tcrossprod(X, Y = NULL)
outer(X, Y) # зовнішній продукт
%o%
```

### Матриці

Матриця може бути транспонована командою `t(x)`

```{r}
t(n)
```

Колонки та рядки матриці можуть мати імена, які можуть бути встановлені відповідно командами `colnames()` та `rownames()`, аналогічно `names()` для векторів. Додати нову колонку або рядок до матриці можливо застосуванням `cbind()` та `rbind()`

```{r}
n <- cbind(n, c(0, 0, 0))
rownames(n) <- LETTERS[1:3]
colnames(n) <- letters[1:4]
n
```

### Сабсетинг матриць

Як вектори, але мають додатковий вимір, тому у `[` ідуть два значення, перше вказує на рядок, друге на колонку

```{r}
n[[2, 3]] # другий елемент третьої колонки
n[1:2, 1:2]
n[2, ]  # другий рядок повністю 
n[ ,3]  # третя колонка повністю 
n[, 3, drop = FALSE] # збереження розмірності

typeof(n) # матриця не є типом, як не дивно
class(n)
class(n[, 3])
class(n[, 3, drop = FALSE]) 
```

### {#slide-id8 data-menu-title="Сабсетинг матриць"}

*P.s* Ви могли помітити, що об'єкт окрім класу `matrix` також мав клас `array` — масив. Окрім двомірних матриць можливо створювати структури вищої розмірності. Сабсетинг такий самий, просто з оглядом на додаткові виміри
```{r}
arr <- array(1:18, c(3, 3, 2)) # простий приклад, може бути гірше
arr

arr[1, 3, 2]
```


### Кадри даних (Data Frames)
Прямокутні структури, що мають колонки та рядки. Подібні за властивостями до листів, фактично кажучи колонки кадрів даних і є векторами листів — таким чином *колонки* мають включати у себе об'єкти одного типу, у той час як *рядки* можуть містити об'єкти різних типів.


Створити кадр даних можливо командою `data.frame()`, вказавши імена та значення для колонок:

```{r}
df <- data.frame(
  char = c(letters[1:4]),
  int = 1:4,
  dbl = runif(4))
df
```

Краще зрозуміти як можуть виглядати кадри даних можливо через ознайомлення з класичними датасетами представленими у R, наприклад `mtcars` або `iris`. Або взяти щось менш популярне.

```{r}
data(crabs, package = "MASS") # це експліцитно завантажить ці данні у Ваш робочій простір
#?MASS::crabs щоб дізнатися більше про набір даних 
```

Щоб інтерактивно переглянути кадр даних у більш звичному стилі електронної таблиці викличте `View(x)` 

### Кадри даних
Швидке знайомство з кадром даних можливо провести переглянувши декілька перших рядків у консолі
```{r}
head(crabs, n = 5)
```
Або краще, переглянувши його структуру
```{r}
str(crabs)
```

### Кадри даних
Для приєднання нових колонок / рядків використовуються тіж команди, що і у випадку матриці
```{r}
colnames(crabs) <- c(colnames(crabs)[1:3], "front_lobe", "rear_wd", 
                  "carapace_l", "carapace_wd", "body_depth")
crabs <- cbind(crabs, species = rep("crab", nrow(crabs)))

head(crabs, 5)
```

Сабсетинг є дещо міксом між матрицями та листами, але зазвичай це не стає проблемою
```{r}
small_crabs <- head(crabs, n = 3) # маленький шматок для демонстрації
```

### Сабсетинг кадрів даних 

```{r}
small_crabs[4:9]   # колонки з 4 по 9, сабсетинг як лист
small_crabs[, 4:9] # теж саме, сабсетинг як матриця
small_crabs[2, 1:4]

str(small_crabs["index"])   # зберігає структуру
str(small_crabs[, "index"]) # симліфікація до атомарного вектору, як і у випадку матриці
str(small_crabs[, "index", drop = FALSE])
str(small_crabs$index) # також дроп структури
```

### Сабсетинг кадрів даних
```{r}
typeof(small_crabs["index"]) # можна впевнитися, що колонки кадрів дійсно є листами
# як і з листами, NULL можна використати, щоб видалити колонку
small_crabs$species <- NULL
small_crabs

# так само додати нову
small_crabs$new_val <- NA # NA для прикладу, сюди можна присвоїти значення одразу
small_crabs

# базове практичне застосування з іншими функціями
mean(small_crabs$rear_wd)
max(small_crabs$front_lobe)
```

