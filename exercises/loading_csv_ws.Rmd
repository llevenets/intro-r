---
title: "Loading csv worksheets"
output: 
  html_notebook:
    highlight: pygments
---

```{r}
library(tidyverse)
```

Завантаження даних у форматі .csv, що є розбитими на декілька файлів. У даному прикладі використовуються дані, що знаходяться у розділі data-examples. Назва необхідних csv файлів складається з двох компонентів - видового епітету злакової рослини (aestivum, dicoccum, secale) та осьового органу рослини, для якого було виконано замір довжини (roots або shoots).

Усі файли мають однакову структуру: перша безіменна колонка ідентифікує кожен окремий об'єкт спостереження за номером, друга колонка під назвою Length вказує на довжину осьового органу рослини (у мм). Один і той самий порядковий номер у файлах -roots.csv та -shoots.csv вказує, що заміри належать одному і тому ж об'єкту. У випадку, якщо вимірювання для якогось з об'єктів не було проведено, відсутність значень позначено канонічним записом NA

Заміри довжин осьових органів було проведено за 5 різних варіантів обробки зернівок. Колонка, яка б містила дані щодо варіанту обробки, відсутня у вхідних даних, проте відомо що об'єкти з порядковим індексом від 1 до 24 було оброблено AgNPs у концентрації 20 ppm, від 25 до 48 - концентрації 40 ppm, від 49 до 72 - 80 ppm, об'єкти під індексом 73-96 належали до контрольної групи, об'єкти з індексом 97-120 оброблялися екстрактом C. annuum.

Перевіримо які файли підходять під вказаний паттерн імені

```{r}
list.files("./data-examples", pattern = "(roots|shoots)\\.csv$", full.names = TRUE)
```

Збережемо шлях до вказаних файлів у окремій змінній

```{r}
paths <- list.files("./data-examples", pattern = "(roots|shoots)\\.csv$", full.names = TRUE)
paths
```

Дані csv файли містять лише безпосередньо необхідні дані, NA є представленими у стандартному форматі, єдиним недоліком є відсутність дескриптивного імені першої колонки. Для зчитування одного з файлів варто викликати команду подібного виду

```{r}
read_csv(
  "./data-examples/aestivum-roots.csv",
  col_names = c("Id", "Len"),
  col_types = "id",
  skip = 1
)
```

На відміну від `read_excel` функція `read_csv` (та інші з пакету readr) дозволяють використовувати буквені скорочення для задання параметрів `col_types`. У даному випадку `col_types = "id"` є рівноцінним `col_types = cols(Id = col_integer(), Len = col_double())`. Даний аргумент, знову ж таки, є абсолютно опціональним. Якщо залишити його без специфікації, R спробує "вгадати" тип значень шляхом перевірки перших 1000 рядків.

Аргумент `skip = 1` означає пропустити перший рядок даних, що у даному випадку містить імена для колонок. Оскільки я задаю імена через `col_names`, перший рядок має бути пропущено.

Оскільки я не бажаю шість разів викликати однакову команду, я можу використати `lapply` або `purrr:map` що б ітерувати елементи вектору paths, що вказує шляхи до кожного із необхідних мені csv файлів. Я пам'ятаю, що назви моїх файлів містять інформацію про вид рослини та тип осьового органу, на даний момент я збережу цю інформацію передавши її до назв елементів листа, у якому будуть знаходитися прочитані кадри даних.

"Відокремити" ім'я файлу від інших елементів шляху до нього можливо за допомогою функції базового пакету R `basename()`. Дану функцію буде викликано усередині `set_names()`.

```{r}
basename(paths)
```

Фінальна конструкція для читання усіх файлів в один лист

```{r, echo=TRUE}
my_data <- paths |> 
  set_names(basename) |> 
    map(
    \(path) 
    read_csv(
    path,
    col_names = c("Id", "Len"),
    col_types = "id",
    skip = 1
   )
  )
```

Залишилося зібрати усе це у спільний кадр даних. Вихідний кадр мусить мати окрім колонок Id та Len, колонку, яка будить містити значення виду рослини, значення типу обробки. Колонка Len має бути трансформована у дві окремі колонки, що будуть містити довжини кореня та пагона специфічні для кожного об'єкту спостереження.

Для того, щоб відокремити видовий епітет рослини та тип осьового органу, значення для яких наразі разом є кодованими у імені елементів листа, буде використано функцію `separate_wider_delim`. Для того щоб трансформувати значення довжини на окремі колонки для довжини кореня та пагона буде використано `pivot_wider`. Колонка, що буде містити варіанти обробки рослин, буде створена de novo за допомогою `mutate`

```{r}
my_data <- my_data |> 
  list_rbind(names_to = "Spec") |> # колонка для видового епітету, 
  separate_wider_delim(            # наразі містить у собі повну назву взяту від імені елементів листа
    Spec,
    delim = "-",
    names = c("Spec", "Org"),     # видовий епітет відділено від типу органу
  ) |> 
  separate_wider_delim(
    Org,
    delim = ".",
    names = c("Org", NA)          # викидаємо інформацію про розширення файлу 
  ) |> 
  pivot_wider(
    names_from = Org,             # трансформуємо колонку з параметром довжини
    values_from = Len,
    names_prefix = "Len_"         # префікс для імені є опціональним аргументом
  ) |> 
  mutate(                         # створюємо колонку з варіантами обробки, 
    Treat = factor(rep(rep(c("20ppm", "40ppm", "80ppm", "control", "extract"), each = 24), 3)),                          
    Spec = factor(Spec)
  ) |>  
  relocate(Id, .before = everything())
  
```

Готовий результат

```{r}
my_data
```
