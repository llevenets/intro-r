---
title: "Loading excel worksheet"
output: 
  html_notebook:
    highlight: pygments
---
```{r}
library(tidyverse)
library(readxl)
```

На прикладі маленького датасету plantlets-cd.xlsx, що знаходиться у розділі data-examples. 

Перевірити які файли знаходяться у певному директорії можливо викликом list.files().
Я хочу перевірити конкретно наявність файлів у форматі .xls / .xlsx
```{r}
list.files(path = "./data-examples", pattern = "\\.xlsx?$", full.names = TRUE)
```

У даному форматі за вказаною адресою присутній лише один файл тому я збережу шлях до цього файлу у тимчасовій змінній аби не прописувати його вручну
```{r}
path <- list.files(path = "./data-examples", pattern = "\\.xlsx?$", full.names = TRUE)
# перевірка
path
```

Необхідні мені данні містяться лише у перших 4 колонках електронної таблиці, окрім того таблиця має неканонічний варіант представлення відсутніх даних (na замість NA / пустих комірок) та несинтактичні імена колонок. Тому аби завантажити даний файл мені необхідно викликати команду з такими аргументами
```{r}
read_xlsx(
  path,
  range = "A2:D25",
  col_types = "numeric",
  col_names = c("control", "Cd25", "Cd50", "Cd100"),
  na = c("na", "")
)
```

Аргумент `range` вказує яку конкретно частину таблиці необхідно прочитати. Оскільки я одразу бажаю задати нові імена колонкам, використавши `col_names` я пропускаю першу строку у таблиці, яка містить старі імена (тому "A2:D25", а не "A1:D25"). 

Аргумент `col_types` дозволяє задати тип передбачений тип даних у колонці, у даному випадку усі 4 колонки містять однаковий тип. Якщо колонки різного типу, наприклад перша логічна, друга-третя чисельна та четверта текстова, то до аргументу необхідно подати вектор відповідної довжини, кожен елемент якого буде відповідати одній колонці (наприклад `col_types = c("logical", "numeric", "numeric", "text")). Специфікація даного аргументу не обов'язкова, проте вона дозоляє легше відслідити причину можливої помилки при завантажені даних (наприклад наявність тексту у колонці яка має бути чисельною).

Аргумент `na` дозволяє вказати які значення мають розглядатися як NA, у випадку коли вони представлені у вихідних даних у неканонічній формі.

Дана електрона таблиця складається з двох листів, дефолтно считується перший лист, специфікувати який лист має бути прочитаним можливо через аргумент `sheet`. Оскільки обидва листи мають однакову структуру, я не бажаю два рази прописувати одну й ту ж команду для їх завантаження. Замість цього можливо скористатися функціоналом `lapply` або `purr::map`.

Зчитаємо назви листів електронної таблиці в окрему змінну
```{r}
sheets <- excel_sheets(path) 
# перевірка
sheets
```

Скористаємося функціоналом аби ітерувати через елементи у новоствореній змінній sheets та використати кожен елемент як значення для аргументу `sheet`
```{r}
my_data <- map(
  sheets,
  \(sheet) 
  read_xlsx(
  path,
  sheet = sheet,
  range = "A2:D25",
  col_types = "numeric",
  col_names = c("control", "Cd25", "Cd50", "Cd100"),
  na = c("na", "")
)
)
# перевірка
str(my_data)
```

Маємо лист довжиною 2, кожен елемент якого містить кадр даних, що відповідає одному із листів електроної таблиці. Додамо назви листів, аби краще орієнтуватися, що де знаходиться
```{r}
my_data <- set_names(my_data, sheets)
# перевірка
str(my_data)
```

Зберемо лист до одного спільного кадру даних, одночасно переведемо його з широкої форми до довгої. Спільний кадр буде мати нову колонку під назвою `org`, що буде вказувати чи відносяться дані виміри до кореня чи до пагона рослини
```{r}
my_data <- my_data |> 
  list_rbind(names_to = "org") |> # імена беруться від назви елементів листа
  pivot_longer(
    where(is.numeric), # провести перетворення по всім колонкам, що мають чисельні значення
    names_to = "dose", # альтернативно можна було б вказати 2:5 або control:Cd100
    values_to = "len"
  ) |> 
  mutate(
    across(where(is.character), as.factor) # перетворити усі текстові колонки на фактори
  )
```

Фінальний результат
(на справді ні, кадр даних слід додатково почистити від NA значень та перевірити на можливі помилки при введені чисельних даних)
```{r}
my_data
```

